<!DOCTYPE html><html lang="en" class="aspect-16-9"><head><meta charset="UTF-8"><meta name="generator" content="Asciidoctor 0.1.4, dzslides backend"><title>WildFly 8 的新特性</title><meta name="author" content="作者 Arun Gupta"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton:400,700,800,400italic|Cedarville+Cursive"><link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.min.css"><link rel="stylesheet" href="./dzslides/themes/highlight/asciidoctor.css"><link rel="stylesheet" href="./dzslides/themes/style/asciidoctor.css"><style>section:not(.topic) > h2 { display: none;}</style><link rel="stylesheet" href="./dzslides/core/dzslides.css"><link rel="stylesheet" href="./dzslides/themes/transition/fade.css"></head><body><section class="title"><h1>WildFly 8 的新特性</h1><footer><span class="author">作者 Arun Gupta</span><span class="divider">&nbsp;&middot;&nbsp;</span><span class="author">Red Hat</span><span class="divider">&nbsp;&middot;&nbsp;</span><span class="author">@arungupta</span></footer></section><section class="topic source"><h2>Arun Gupta</h2><div class="exampleblock"><div class="content"><ul><li>Director, Developer Advocacy, Red Hat Inc.</li><li>O&#8217;Reilly and McGraw Hill author</li><li>Fitness freak</li></ul></div></div>
<details><details open=""><summary>Notes</summary><ul><li>My name is Arun Gupta, and I drive community engagement efforts for JBoss at Red Hat</li><li>I&#8217;ve authored couple of O&#8217;Reilly best selling books and another one by McGraw Hill</li><li>I&#8217;m a workout nut as my kids call me and a runner</li></ul></details></details></section>
<section class="topic source"><h2>zeroturnaround.com</h2><p><span class="image"><img src="images/zeroturnaround.png" alt="zeroturnaround"></span> <span class="image"><img src="images/trophy.png" alt="trophy"></span></p>
<details><details open=""><summary>Notes</summary><ul><li>What we’re looking at in this part of the report are the real developer concerns and metrics including:<ul><li>Ease of download and installation</li><li>Real performance metrics</li><li>Tooling support</li><li>Server Configuration</li></ul></li><li>WebLogic and WebSphere were not included as these servers are really targeted for large-enterprises and apps in production rather than lightweight development</li><li>Each server was ranked from 1 to 5</li></ul></details></details></section>
<section><blockquote><p>If we had to pick a <strong>winner</strong>, it would be <strong>JBoss</strong>. The only application server in the group whose score <strong>never dropped below a 4</strong></p><br><cite>zeroturnaround.com</cite></blockquote>
<details><details open=""><summary>Notes</summary><p>Highhlight:
* JBoss is the winner from all the servers studied
* Scores range from 1-5 with JBoss never going below 4
* JBoss AS version ??</p></details></details></section>
<section><blockquote><p>JBoss <strong>consistently</strong> performs <strong>very well</strong> in each category which is why it also <strong>shines</strong> in the developer profiles exercise</p><br><cite>zeroturnaround.com</cite></blockquote></section>
<section><img class="middle" src="images/wildfly.png" alt="wildfly">
<details><details open=""><summary>Notes</summary><p>Lets take a look at WildFly and what is it!</p></details></details></section>
<section><p class="statement"><code>目标:</code><br>
理解 <em>WildFly 8</em> 的<em>新特性</em>,以及 <em>AS 7.X</em> 的一些功能的<em>改进</em></p>
<details><details open=""><summary>Notes</summary><ul><li>The aim of today&#8217;s presentation is &#8230;</li><li>&#8230; to learn the new features of WildFly 8</li><li>&#8230; learn some of the main features that already existed in AS 7.x and carried forward.</li></ul></details></details></section>
<section class="topic"><h2>WildFly 8 是什么?</h2><ul class="incremental"><li>原先为 “JBoss应用服务器(Application Server)”</li><li>是红帽JBoss企业应用平台(JBoss EAP)的上游项目</li><li>快速，轻量，可管理的</li><li>对开发人员友好</li><li>支持 Java EE 标准</li><li>开源</li></ul>
<details><details open=""><summary>Notes</summary><ul><li>The new name is relevant because it differentiates our community project from the commercial offering. After JBoss AS 7.1.2,the community offering is renamed to WildFly. This is the upstream project for JBoss Enterprise Application Platform. Main focus of WildFly is to meet community demands by rapid releases and latest in innovation. EAP is focused towards a more conservative branch, which is battle-tested for mission critical deployments.</li><li>WildFly provides a lightweight managed application runtime. WildFly provides a unified management layer fully integrated with all aspects of server and is exposed using a variety of APIs and protocols. These could be used to automate operational needs of any environment – small JVM on a tiny server or thousands of JVM spread across the world.</li><li>For JBoss, developer is the key. So from the very beginning WildFly is designed to be easy and quick to get going. It offers rapid boot time, excellent developer tooling through not just JBoss Tools project and NetBeans plugin but also community–contributed IntelliJ, and a wide variety of quick start examples.</li><li>WildFly implements the latest Java EE standards as well as additional open source innovative APIs. While Java EE is the most common usage of WildFly but it is not tied to any particular language or SDK. For example, TorqueBox provides full Ruby-on-Rails experience and is based on WildFly architecture and use many of its core features.</li><li>The source code is completely open source and available to you for free. If you have an issue with your application, you can attach a debugger and find out what might be causing the issue. You can file a bug, and then send a pull request for the patch to be applied.</li></ul></details></details></section>
<section class="topic source"><h2>WildFly 8 主要特性</h2><ul class="incremental"><li>Java EE7 支持</li><li>高性能的Web服务器 <em>Undertow</em></li><li>减少端口使用</li><li>基于角色的管理控制和审计能力</li><li>自动打补丁机制</li><li>最小的 "core" 发布包</li></ul>
<details><details open=""><summary>Notes</summary><ul><li>WildFly 8 is Java EE 7 compliant and brings all the great technologies added to the platform.</li><li>It also adds a new high performance and flexible Web server.</li><li>Another important feature in WildFly is the ability to segment administrative responsibilities based upon different user roles. This allows users to be restricted to specific areas of console such as to deploy an application or access privileged resources. This is commonly called as Role Based Administration Control (RBAC).</li><li>Also a special audit log with actions of the user is enabled and this log can then be uploaded to a secure location.</li><li>Automated patching ?</li></ul></details></details></section>
<section class="topic source"><h2>WildFly: Java EE 7</h2><img src="images/javaee7.png" alt="javaee7">
<details><details open=""><summary>Notes</summary><ul><li>Java EE 7 is the latest release of the platform and focuses around increasing productivity and embracing HTML5. WildFly 8 is Java EE 7 compliant and so you get all the technologies from the platform here.</li><li>WebSocket (JSR 356), Batch (JSR 352), JSON (JSR 353), Concurrency Utilities for Java EE (JSR 236) are four new techonlogies in the platform. JAX-RS 2 (JSR 339) and JMS 2 (JSR 343) went through significant updates. CDI 1.1 (JSR 346), Bean Validation 1.1 (JSR 349), JPA 2.1 (JSR 338), JTA 1.2 (JSR 907) also made updates.</li><li>Lets take a look at some Java EE 7 sample code.</li></ul></details></details></section>
<section class="topic source"><h2>WildFly: Java EE 7 WebSocket</h2><div class="listingblock"><div class="title"><code>ChatServer.java</code></div><pre class="highlight CodeRay"><code class="java">@ServerEndpoint("/chat") <i class="conum" data-value="1"></i><b>(1)</b>
public class ChatEndpoint {
    @OnMessage <i class="conum" data-value="2"></i><b>(2)</b>
    public void message(String message,
                        Session client) <i class="conum" data-value="3"></i><b>(3)</b>
                   throws IOException, EncodeException {
        for (Session peer : client.getOpenSessions()) {
            peer.getBasicRemote().sendText(message);
        }
    }
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>创建 WebSocket 端点, 定义 URL</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>设定方法来接收WebSocket消息</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>处理WebSocket消息报文</td></tr></table></div>
<details><details open=""><summary>Notes</summary><ul><li>The Java API for WebSocket, WebSocket 1.0, is a key technology for HTML5 support. WebSocket provides a bi-directional and full-duplex communication channel over a sigle TCP connection.</li><li>Adding <code>@ServerEndpoint</code> annotation on a POJO converts it into a WebSocket server endpoint. No additional deployment descriptors are required. The URL at which the endpoint is published is included in the annotation.</li><li>The POJO method that needs to be invoked is marked with <code>@OnMessage</code> and the payload of the message is automatically mapped to the method parameter.</li><li>First parameter receives the payload, second parameter marks the conversation from the client.</li><li>Method implementation iterate over all the connected clients and broadcast the received payload.</li></ul></details></details></section>
<section class="topic source"><h2>WildFly: Java EE 7 Batch</h2><div class="listingblock"><div class="title"><code>job.xml</code></div><pre class="highlight CodeRay"><code class="xml">&lt;job id="myJob" xmlns="http://xmlns.jcp.org/xml/ns/javaee" version="1.0"&gt;
    &lt;step id="myStep" &gt;
        &lt;chunk item-count="3"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
            &lt;reader ref="myItemReader"/&gt; <i class="conum" data-value="2"></i><b>(2)</b>
            &lt;processor ref="myItemProcessor"/&gt; <i class="conum" data-value="3"></i><b>(3)</b>
            &lt;writer ref="myItemWriter"/&gt; <i class="conum" data-value="4"></i><b>(4)</b>
        &lt;/chunk&gt;
    &lt;/step&gt;
&lt;/job&gt;</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>对数据记录逐个进行处理，数据块的记录的个数</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>数据块处理，读出记录</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>数据块处理，处理记录</td></tr><tr><td><i class="conum" data-value="4"></i><b>4</b></td><td>数据块处理，写入记录</td></tr></table></div>
<details><details open=""><summary>Notes</summary><ul><li>Batch Processing provides item-oriented (aka chunk, and preferred style) and task-oriented (aka batchlet) processing. This is a job description of chunk processing, aka Job XML.</li><li>Job XML typically consists of many steps, this canonical sample contains one chunk step.</li><li>This chunk has a reader, processor, and writer. The ref attribute refers to CDI resolvable bean name bundled with the archive.</li><li>The item-count attribute defines the chunk size, i.e. the number of items processed at one time.</li><li>The reader, processor, and writer work together for a chunk number of items at a time.</li><li>All of this is done within a transaction, with automatic checkpointing.</li></ul></details></details></section>
<section class="topic source"><h2>WildFly: Java EE 7 JSON</h2><div class="listingblock"><div class="title"><code>CreateJson.java</code></div><pre class="highlight CodeRay"><code class="java">JsonObject jsonObject = Json.createObjectBuilder() <i class="conum" data-value="1"></i><b>(1)</b>
                .add("apple", "red") <i class="conum" data-value="2"></i><b>(2)</b>
                .add("banana", "yellow")
                .build(); <i class="conum" data-value="3"></i><b>(3)</b>
StringWriter w = new StringWriter();
JsonWriter writer = Json.createWriter(w); <i class="conum" data-value="4"></i><b>(4)</b>
writer.write(jsonObject);</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>创建JSON对象构建器</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>加入名称/值到JSON对象</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>返回构建好的JSON对象</td></tr><tr><td><i class="conum" data-value="4"></i><b>4</b></td><td>通过JsonWriter写入</td></tr></table></div>
<details><details open=""><summary>Notes</summary><ul><li>JSON is a key technology for data transfer within HTML5 applications. With JSON 1.0, Java EE 7 adds new APIs to enable the parsing and generation of JSON text and objects.</li><li>JSON API provides streaming and object model API to parse and generate JSON. This is an object-model API sample.</li><li><code>JSONObject</code> is created and key/value name pairs are added using convenient <code>add</code> methods.</li><li>Created object can be written to <code>java.io.Writer</code> or <code>java.io.OutputStream</code>.</li></ul></details></details></section>
<section class="topic source"><h2>WildFly: Java EE 7 Concurrency</h2><div class="listingblock"><div class="title"><code>RunMyTask.java</code></div><pre class="highlight CodeRay"><code class="java">public class MyTask implements Runnable { <i class="conum" data-value="1"></i><b>(1)</b>

    @Override
    public void run() {
        . . .
    }
}

@Resource(name = "DefaultManagedExecutorService") <i class="conum" data-value="2"></i><b>(2)</b>
ManagedExecutorService defaultExecutor;

executor.submit(new MyTask()); <i class="conum" data-value="3"></i><b>(3)</b></code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td><code>Runnable</code> 或者 <code>Callable</code> 任务可以被提交</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td><code>ManagedExecutor</code> 被注入, 提供缺省的服务资源</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>提交要执行的任务</td></tr></table></div>
<details><details open=""><summary>Notes</summary><ul><li>Concurrency Utilities is a new addition to the Java EE 7 platform and is an extension of the Java SE Concurrency Utilities API. This API provides asynchronous capabilities to Java EE application components, at a lower level than the existing asynch APIs (offered by EJB, Servlet, JAX-RS), and thus gives you a finer-grain level of control and configuration.</li><li>API provides 4 types of managed objects, one of them is <code>ManagedExecutorService</code>.</li><li>Task can be defined as <code>Runnable</code> or <code>Callable</code>.</li><li>Platform provides a default instance of <code>ManagedExecutorService</code> which can be easily injected using <code>@Resource</code>.</li><li>Usual calls from JSR 166y are now available. All standard Java SE Concurrency APIs and design patterns are available for us. The big difference is that the threads created here are managed by the application server now. The JNDI, class loading, security context information is available to these tasks. This was not available earlier.</li></ul></details></details></section>
<section class="topic source"><h2>WildFly: Java EE 7 JAX-RS</h2><div class="listingblock"><div class="title"><code>RunClient.java</code></div><pre class="highlight CodeRay"><code class="java">Client client = ClientBuilder.newClient(); <i class="conum" data-value="1"></i><b>(1)</b>
WebTarget target = client.target("..."); <i class="conum" data-value="2"></i><b>(2)</b>
target.register(Person.class);
Person p = target
             .path("{id}") <i class="conum" data-value="3"></i><b>(3)</b>
             .resolveTemplate("id", "1")
             .request(MediaType.APPLICATION_XML) <i class="conum" data-value="4"></i><b>(4)</b>
             .get(Person.class); <i class="conum" data-value="5"></i><b>(5)</b></code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td><code>ClientBuilder</code> 客户端入口点</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>创建一个新的资源目标点，给出URL路径</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>id定义</td></tr><tr><td><i class="conum" data-value="4"></i><b>4</b></td><td>定义可接收的媒体类型</td></tr><tr><td><i class="conum" data-value="5"></i><b>5</b></td><td>调用HTTP GET命令, 并限定资源类型</td></tr></table></div>
<details><details open=""><summary>Notes</summary><ul><li>JAX-RS 2.0 now adds a client-side API to access a REST endpoint in a standard way.</li><li>An instance of <code>Client</code> is required to access a Web resource using the Client API. The default instance of Client can be obtained by calling newClient on <code>ClientBuilder</code>.</li><li>A Web resource can be accessed using a fluent API in which method invocations are chained to build and ultimately submit an HTTP request.</li><li>Conceptually, the steps required to submit a request are the following:<ul><li>obtain an instance of <code>Client</code></li><li>create a <code>WebTarget</code></li><li>create a request from the <code>WebTarget</code></li><li>submit a request or get a prepared Invocation for later submission</li></ul></li><li>The benefits of using a <code>WebTarget</code> become apparent when building complex URIs, for example by ex- tending base URIs with additional path segments or templates. Note the use of the URI template parameter <code>{orderId}</code>. The exact value of this template parameter is resolved using <code>resolveTemplate()</code> method.</li><li>The response to a request typed in the invocation of <code>get()</code> method. In this case, a String representation is returned back. This can also be a POJO where on-the-wire format is converted to POJO using JAX-RS entity providers.</li></ul></details></details></section>
<section class="topic source"><h2>WildFly: Java EE 7 JMS</h2><div class="listingblock"><div class="title"><code>SendMessage.java</code></div><pre class="highlight CodeRay"><code class="java">@JMSDestinationDefinition(name="myQueue", interfaceName="javax.jms.Queue") <i class="conum" data-value="1"></i><b>(1)</b>

@Resource(mappedName="myQueue")
Queue syncQueue;

@Inject
// @JMSConnectionFactory("java:comp/DefaultJMSConnectionFactory") <i class="conum" data-value="2"></i><b>(2)</b>
private JMSContext context; <i class="conum" data-value="3"></i><b>(3)</b>

context.createProducer().send(syncQueue, "..."); <i class="conum" data-value="4"></i><b>(4)</b></code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>JMSDestinationDefinition资源的创建和命名</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>缺省的 JMS connection factory</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>简化的主要接口JMSContext</td></tr><tr><td><i class="conum" data-value="4"></i><b>4</b></td><td>流式构建API</td></tr></table></div>
<details><details open=""><summary>Notes</summary><ul><li>JMS has undergone a major simplification with the JMS 2.0 by offering the simple and easier-to-use API and  offloading developer tasks onto container services.</li><li>Sending and receiving a message using JMS 1.1 required a lot of boilerplate code. JMS 2.0 has really fixed this with the addition of the new JMS simplified API and, in particular, the <code>JMSContext</code> interface.</li><li><code>JMSContext</code> combines in a single object the functionality of both the <code>Connection</code> and the <code>Session</code> in the earlier JMS APIs. A container-managed <code>JMSContext</code> instance can be obtained by simply injecting it with the <code>@Inject</code> annotation. Notice, no <code>ConnectionFactory</code> is specified here. In this case, a default JMS ConnectionFactory is used by and this is defined by the platform.</li><li>A <code>Destination</code>, a <code>Queue</code> in this case, is injected using <code>@Resource</code>. Even this annotation can be created using newly introduced <code>@JMSDestinationDefintion</code> annotation which would automatically create the destination.* Finally, the message is sent using method chaining. For example, create a producer using <code>createProducer()</code> and then calling <code>send()</code> method to send a message to a destination.</li><li>Really simple and clean. This also improves semantic readability of your code.</li></ul></details></details></section>
<section class="topic source"><h2>WildFly: Java EE 7 IDEs</h2><p><span class="image"><img src="images/netbeans-wildfly.png" alt="netbeans-wildfly"></span> <span class="image"><img src="images/eclipse-wildfly.png" alt="eclipse-wildfly"></span> <span class="image"><img src="images/intellij-wildfly.png" alt="intellij-wildfly"></span>
<span class="image"><img src="images/netbeans-logo.png" alt="netbeans-logo"></span> <span class="image"><img src="images/jbosstools-logo.png" alt="jbosstools-logo"></span> <span class="image"><img src="images/intellij-logo.png" alt="intellij-logo"></span></p></section>
<section class="topic source"><h2>WildFly: 新的 web 服务器 (<em>Undertow</em>)</h2><ul class="incremental"><li>可扩展，高性能</li><li>基于阻塞/非阻塞的NIO API</li><li>基于Composition/handler架构</li><li>轻量的，可以被嵌入使用</li><li>支持 Servlet 3.1 和 HTTP upgrade 协议</li><li><code>mod_cluster</code> 支持</li></ul>
<details><details open=""><summary>Notes</summary><ul><li>Undertow is a flexible performant web server written in java, providing both true blocking and non-blocking API’s based on NIO. It has the ability to scale to a million connections and has impressive numbers on throughput. It also allows us to add support for modern security standards. And since web server is one of the most critical pieces of an application server, writing it a fresh allows us to provide the best possible performance and memory efficiency.</li><li>Undertow has a composition based architecture that allows you to build a web server by combining small single purpose handlers. The gives you the flexibility to choose between a full Java EE servlet 3.1 container, or a low level non-blocking handler, to anything in between.</li><li>Undertow is designed to be fully embeddable, with easy to use fluent builder APIs. Undertow’s lifecycle is completely controlled by the embedding application.</li><li>Undertow provides support for Servlet 3.1, including support for embedded servlet. It is also possible to mix both Servlets and native undertow non-blocking handlers in the same deployment. It allows to upgrade from HTTP to our native protocols.</li></ul></details></details></section>
<section class="topic source"><h2>WildFly 新的 web 服务器: <em>Undertow</em></h2><div class="listingblock"><div class="title"><code>NonBlockingHandler.java</code></div><pre class="highlight CodeRay"><code class="java">Undertow.builder() <i class="conum" data-value="1"></i><b>(1)</b>
  .addListener(8080, "localhost")
  .setHandler(new HttpHandler() { <i class="conum" data-value="2"></i><b>(2)</b>
    @Override
    public void handleRequest(final HttpServerExchange exchange)
      throws Exception {
      exchange.getResponseHeaders()
              .put(Headers.CONTENT_TYPE, "text/plain");
      exchange.getResponseSender()
              .send("Hello World");
    }
  }).build().start(); <i class="conum" data-value="3"></i><b>(3)</b></code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>流式API来构建</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>可以创建使用多个handler</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>启动handler</td></tr></table></div>
<details><details open=""><summary>Notes</summary><p>Read through the code ;-)</p></details></details></section>
<section class="topic source"><h2>WildFly: 端口减少</h2><ul class="incremental"><li>使用 HTTP Upgrade</li><li>缺省安装后打开的端口只有两个<ul><li><em>8080</em> Web应用程序</li><li><em>9990</em> 管理界面</li></ul></li><li>通过HTTP Upgrade来处理各种请求</li></ul>
<details><details open=""><summary>Notes</summary><ul><li>By utilizing HTTP upgrade, WildFly 8 has moved nearly all of its protocols to be multiplexed over two HTTP ports: a management port, and an application port. This is a big benefit to cloud providers (such as OpenShift) who run hundreds to thousands of instances on a single server. This is another example of why JBoss is designed for the cloud / PaaS. The better examples are small memory footprint and fast startup (delivered in AS 7).</li><li>Note that since CR1 we have finally dropped the native management port 9999, which instead uses the HTTP management port (9990). Our full profile configuration also dropped the native JMS ports 5445 and 5455, which instead are multiplexed over port 8080. However, all of these original ports can still be enabled if desired.</li><li>At some point, we may offer a single port mode, to allow all server traffic to go through a single port.</li></ul></details></details></section>
<section class="topic source"><h2>WildFly: 基于角色的访问控制Role based access control</h2><ul class="incremental"><li>预先定义的管理和特权用户<em>角色(Roles)</em><ul><li>Monitor, Operator, Maintainer, Deployer, Administrator, Auditor, Super User</li></ul></li><li>角色赋予<em>权限(Permissions)</em></li><li>权限限定了可以对资源的各种 <em>操作(Actions)</em> (lookup, read, write)</li><li><em>用户(Users)</em>和<em>组(Groups)</em>在角色中定义</li></ul>
<details><details open=""><summary>Notes</summary><ul><li>Role Based Access Control (RBAC) is the ability to restrict access to system or certain portions of it to authorized users. For JBoss AS 7.x or JBoss EAP 6.0 and 6.1, the web-based administrative console had an all-or-nothing approach. So if a user can authenticate with management security realm, then he&#8217;ll have all the privileges. This might be OK for smaller deployments but the roles are typically divided for mission critical deployments and a finer-grained control is required.</li><li>JBoss EAP 6.2 and WildFly 8 introduces RBAC using different roles. There are essential 7 different roles in 2 different categories – administrative and privileged.</li><li>Each Role is defined as a set of Permissions and Permissions specify what Actions are permitted by the logged in user, which is basically lookup, write, or delete.</li></ul></details></details></section>
<section class="topic source"><h2>WildFly: 管理审计日志</h2><ul class="incremental"><li>记录所有连接认证事件</li><li>记录所有管理操作</li><li>记录信息是JSON格式</li><li>通过不同handlers记录到<ul><li>本地文件</li><li>Syslog (UDP / TCP / TLS)</li></ul></li></ul>
<details><details open=""><summary>Notes</summary><ul><li>WildFly comes with audit logging built in for management operations affecting the management model. By default it is turned off. The information is output as JSON records.</li><li>RBAC and Audit Logging certainly makes the server enterprise grade. But EAP (not WildFly) is certify to very military-grade security standards - namely Common Criteria (EAL 4+) so it can be deployed in highly sensitive, restrictive environments; or even banks ;). Features like Audit Logging and RBAC make it possible.</li></ul></details></details></section>
<section class="topic source"><h2>WildFly: 自动补丁机制</h2><ul class="incremental"><li>允许在安装时做库文件和配置的升级更新</li><li>补丁包含升级用到的文件和元数据信息，打包成zip文件</li><li>多次补丁包可以合并</li><li>可以回滚来撤销升级</li></ul>
<details><details open=""><summary>Notes</summary><ul><li>The infrastructure to support the application of patches to an existing install has been implemented. This capability allows for a remote client to install and rollback new static modules and binary files using the WildFly management protocol.</li><li>This feature will be used in future for EAP.</li></ul></details></details></section>
<section class="topic source"><h2>WildFly: 最小的 "core" 发布包</h2><ul class="incremental"><li>15 MB</li><li>管理能力</li><li>完整的并发服务控制框架</li><li>模块化的类加载，可以用于多租户应用</li><li>可插拔的热部署层</li><li>内置轻量的web服务器</li></ul>
<details><details open=""><summary>Notes</summary><ul><li>A new download option is now available in WildFly 8, called the "core" distribution. This distribution is ideal for framework authors that want to build their own application runtime using the powerful WildFly 8 architecture.</li><li>This allows to add new subsystems, add new deployment types, your application needs to take advantage of the powerful CLI for managementaspect, etc. This is nothing to do with an existing standard like Java EE or anything else, its purely related to how WildFly internals work.</li><li>Management, classloading (JBoss Modules), logging etc is bare bones, everything else like EJB, JPA, Clustering are extensions to that. Core has a deployment manager but it does not know what to do with the uploaded archive, such as WAR, unless an extension is uploaded.</li><li>Rich management layer supporting configuration persistence, hot runtime updates, and unified set of tools and protocols.</li><li>Built-in lightweight web server (supports the HTTP/JSON management protocol)</li></ul></details></details></section>
<section class="topic source"><h2>WildFly: 其他内容</h2><ul class="incremental"><li>提高 JDK8 兼容性</li><li>RESTEasy 3</li><li>Hibernate search</li><li>预先定义的安全权限</li><li>新的集群API</li><li>取消的内容: CMP, JAX-RPC, JSR 88</li></ul>
<details><details open=""><summary>Notes</summary><ul><li>This release has improved compatibility with JDK8, and we now encourage everyone interested in Java 8 to run WildFly 8 on it as well. Expect future releases of WildFly to include APIs that take advantage of the new language features.</li><li>WildFly 8 includes RESTEasy 3 which supports the standard Java EE REST APIs (JAX-RS 2.0) and also provides a number of useful extensions including JSON Web Encryption, Jackson, Yaml, JSON-P, and Jettison.</li><li>Hibernate Search is now offered out of the box in WildFly. Hibernate Search indexes objects for fast full-text searching. Multiple data sources are supported including Infinispan and standard database entities.</li><li>WildFly now provides a specialized Java security manager that allows you to define per-deployment security permissions, and also greatly improves upon the performance of using the standard Java security manager. In addition to the standard Java EE permissions.xml, a more flexible jboss-permissions.xml descriptor is also supported.</li><li>Allows applications to view cluster topology and listen for topology changes. Allows applications to broadcast/submit commands to nodes in the cluster for remote execution. Requisite modules are automatically made available to deployments, if supported by the server profile.</li><li>CMP - JPA offers much more performant and flexible API. JAX-RPC - JAX-WS offers a much more accurate and complete solution. JSR-88 - Very little adoptionr. Most preferred the more complete deployment APIs provided by venders. We decided to completely remove support for these technologies due to the high maintenance cost, low community interest, and much better alternative solutions. If you are not able to port at this time, we recommend looking at JBoss EAP6, which provides long term maintenance and support of these technologies.</li></ul></details></details></section>
<section class="topic source"><h2>WildFly: 在云端</h2><p><span class="image"><img src="images/openshift-logo.png" alt="openshift-logo"></span> <span class="image"><img src="images/cloudbees-logo.png" alt="cloudbees-logo"></span></p></section>
<section class="topic source"><h2>AS 7.x 延续的特性</h2><div class="exampleblock"><div class="content"><ul><li>独立服务器(Standalone)和管理域(Managed Domain)</li><li>管理配置中心<ul><li>命令行 (jboss-cli)</li><li>管理控制台 (admin console)</li><li>配置文件</li></ul></li></ul></div></div>
<details><details open=""><summary>Notes</summary><ul><li>AS 4, 5, and 6 had the concept of a single independent instance server only. AS 7 introduced the concept of multi-server topology using managed domain.</li><li>It provides multiple ways for centralized administration serving different use cases.</li></ul></details></details></section>
<section class="topic source"><h2>Standalone 和 Managed Domain</h2><ul class="incremental"><li><strong>Standalone</strong>: 单独的实例</li><li><strong>Managed domain</strong>: 多个实例，被配置中心管理<ul><li>Host controller</li><li>Domain controller</li><li>Server group</li><li>Server</li></ul></li></ul>
<details><details open=""><summary>Notes</summary><ul><li>Standalone instance is a single independent instance of server, just like AS 4, 5, and 6. can be started using <code>bin/standalone.sh|bat</code> scripts.<ul><li>This mode is recommended for development.</li><li>If more than one standalone instance is launched and multi-server management is desired, it is the user&#8217;s responsibility to coordinate management across the servers. For example, to deploy an application across all of the standalone servers, the user would need to individually deploy the application on each server.</li></ul></li><li>A managed domain that allows you to run and manage a multi-server topology and manage multiple WildFly instances from a single control point. It can be started using <code>bin/domain.sh|bat</code> scripts.<ul><li>This mode is recommended for production.</li></ul></li></ul></details></details></section>
<section class="topic source"><h2>Managed Domain</h2><img src="images/managed-domain.png" alt="managed domain">
<details><details open=""><summary>Notes</summary><ul><li>Domains can span multiple physical (or virtual) machines, with all WildFly 8 instances on a given host under the control of a special Host Controller process. One Host Controller instance is configured to act as the central Domain Controller. The Host Controller on each host interacts with the Domain Controller to control the lifecycle of the application server instances running on its host and to assist the Domain Controller in managing them.</li><li>Host controller (HC) is started with domain.sh|bat script and is only concerned with server management on that host. Domain Controller (DC) is a special HC that is configured to be the central management control point for the collection of servers in the ‘domain’.</li><li>All of the WildFly 8 instances in the domain share a common management policy, with the Domain Controller acting to ensure that each server is configured according to that policy.</li><li>A server group is set of server instances that will be managed and configured as one. In a managed domain each application server instance is a member of a server group. DC and HC ensures that all servers in a server group have a consistent configuration.</li><li>Server is an actual server instance. It runs in a separate JVM process from HC and is started by HC. User cannot launch this process from command line.</li><li>It&#8217;s important to understand that the choice between a managed domain and standalone servers is all about how your servers are managed, not what capabilities they have to service end user requests. This distinction is particularly important when it comes to high availability clusters. It&#8217;s important to understand that HA functionality is orthogonal to running standalone servers or a managed domain. That is, a group of standalone servers can be configured to form an HA cluster.</li></ul></details></details></section>
<section class="topic source"><h2>命令行</h2><ul class="incremental"><li><code>jboss-cli.sh</code>|<code>bat</code></li><li>连接 standalone 或者 Domain controller</li><li>交互模式: *nix shell风格<ul><li>上下文相关命令，tab补齐功能</li></ul></li><li>非交互模式: 文件中包含要执行的操作</li><li>多个命令组合成一个操作</li><li>每个修改都会被记录</li></ul>
<details><details open=""><summary>Notes</summary><ul><li><code>jboss-cli.sh|bat</code> is Command Line Interface management tool for a standalone server or a managed domain. It allows a user to connect to a standalone server or domain controller and execute management operations.</li><li>All configuration data is persisted in the backing XML configuration files. These files can be directly manipulated as well but require knowledge about them.</li></ul></details></details></section>
<section class="topic source"><h2>控制台</h2><ul class="incremental"><li>简单</li><li>快速</li><li>轻量</li><li>不需要 XML 配置文件</li><li>可以管理实例和域</li><li>完成大多数配置管理功能，以及基本的监视功能<ul><li>注意，不能替代JON(Red Hat JBoss Operations Network)产品
<span class="image"><img src="images/admin-console.png" alt="admin-console"></span></li></ul></li></ul>
<details><details open=""><summary>Notes</summary><ul><li>The Admin Console is a responsive web-based administration console and provides a GUI for all administration tasks.</li></ul></details></details></section>
<section class="topic recap"><h2>WildFly:</h2><div class="exampleblock"><div class="content"><ul><li>Java EE 7 兼容</li><li>轻量的</li><li>可管理的</li><li>高度可扩展</li><li>开源</li><li>应用服务器</li></ul>
<p><em>马上使用!</em></p></div></div></section>
<section class="topic source"><h2>开源技术大会</h2><img src="images/devnation_summitpromo.png" alt="devnation summitpromo"></section>
<section class="topic source"><h2>参考</h2><div class="admonitionblock note"><table><tr><td class="icon"><i class="icon-note" title="Note"></i></td><td class="content">WildFly - <a href="http://wildfly.org">http://wildfly.org</a>, <a href="http://github.com/wildfly">http://github.com/wildfly</a>, @WildFlyAS</td></tr></table></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="icon-note" title="Note"></i></td><td class="content">JBoss EAP 6.2 - <a href="http://redhat.com/jboss">http://redhat.com/jboss</a></td></tr></table></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="icon-note" title="Note"></i></td><td class="content">Java EE 7 samples - <a href="https://github.com/javaee-samples/javaee7-samples">https://github.com/javaee-samples/javaee7-samples</a></td></tr></table></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="icon-note" title="Note"></i></td><td class="content">Slides generated with Asciidoctor and DZSlides backend</td></tr></table></div>
<div class="admonitionblock note"><table><tr><td class="icon"><i class="icon-note" title="Note"></i></td><td class="content">Original slide template - Dan Allen &amp; Sarah White</td></tr></table></div></section>
<section class="topic ending"><h2 class="name">Arun Gupta</h2><p class="footer"><em class="icon-twitter">&#8203;</em> @arungupta</p></section><script src="./dzslides/core/dzslides.js"></script><script src="./dzslides/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad()</script></body></html>